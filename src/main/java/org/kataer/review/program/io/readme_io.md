### IO
#### IO模型
- 阻塞IO模型
```text
读写数据的过程中会发生阻塞现象
```
- 非阻塞IO模型
```text
用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU
```
- 多路复用IO模型
```text
多路复用 IO 比较适合连接数比较多的情况
多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多
```
- 信号驱动IO模型
```text
在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作
```
- 异步IO模型
```text
异步 IO 模型中， IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。
异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO
```

#### BIO、NIO、AIO
```text
BIO 同步阻塞模式
NIO 同步非阻塞
AIO 异步非阻塞
```
#### select、poll和epoll什么区别
```text
NIO多路复用的三种实现机制，由linux系统提供
```
- select
```text
无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作，会维护一个文件描述符FD的集合fd_set，将fd_set从用户空间复制到内核空间。
x86 fd_set是数组结构
```
-poll
```text
与select机制相似，fd_set结构进行优化，突破操作系统限制，pollfd代替fd_set，链表结构
```
-epoll
```text
不再扫描所以fd，只将用户关心的事件放在内核的一个事件表中，减少用户空间和内核空间的数据拷贝。epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们
```
#### java IO和NIO
```text
IO是面向流的，NIO是面向缓冲区的
IO分为字节流[inputStream、outputStream]和字符流[reader、writer]
```
##### java NIO
```text
NIO主要有三大核心部分 Channel、Buffer、Selector
传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据总是从通道读到缓存区，或者从缓存区写到通道中
selector用于监听多个通道的事件
```